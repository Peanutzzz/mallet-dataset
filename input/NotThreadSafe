map util not thread safe public static object compute if absent map target object key bi function mapping function object param1 object param2 object require non null key key object require non null key mapping function object require non null key param1 object require non null key param2 object val target get key if val null object ret mapping function apply param1 param2 target put key ret return ret return val 
buffer no op request indexer internal not thread safe class buffer no op request indexer implement request indexer private concurrent link queue action request buffer request buffer no op request indexer this buffer request new concurrent link queue action request override public void add delete request delete request collection add all buffer request delete request override public void add index request index request collection add all buffer request index request override public void add update request update request collection add all buffer request update request void process buffer request request indexer actual indexer for action request request buffer request if request instanceof index request actual indexer add index request request else if request instanceof delete request actual indexer add delete request request else if request instanceof update request actual indexer add update request request buffer request clear 
file base one shot latch not thread safe public class file base one shot latch implement closeable private final path latch file private final watch service watch service private boolean release public file base one shot latch final path latch file this latch file check not null latch file final path parent dir check not null latch file get parent latch file must have a parent this watch service init watch service parent dir private static watch service init watch service final path parent dir final watch service watch service create watch service parent dir watch for latch file watch service parent dir return watch service private static watch service create watch service final path parent dir try return parent dir get file system new watch service catch i o exception e throw new runtime exception e private static void watch for latch file final watch service watch service final path parent dir try parent dir register watch service new watch event kind standard watch event kind entry create sensitivity watch event modifier high catch i o exception e throw new runtime exception e wait until the latch file be create p when this method return subsequent invocation will not block even after the latch file be delete note that this method may not return if the latch file be delete before this method return throw interrupted exception if interrupt while wait public void await throw interrupted exception if be release or releasable return await latch file watch service private void await latch file final watch service watch service throw interrupted exception while true watch key watch key watch service take if be release or releasable break watch key reset private boolean be release or releasable if release return true if file exist latch file release latch return true return false private void release latch release true override public void close throw i o exception watch service close 
monotonic t t l time provider not thread safe final class monotonic t t l time provider implement ttl time provider serializable private static final long serial version u i d 1 l the follow variable be static because the whole t t l time provider will go through serialization and eventually the state backend and the task execute the ttl verify update function will have different instance of it if these be not static then the ttl verify update function would e g freeze the time but the backend would not be notify about it result in inconsistent state we have to add synchronization because the time provider be also access concurrently from rock d b compaction filter thread private static boolean time be frozen false private static long last return processing time long min value private static final object lock new object guard by lock static t e extend throwable t do with frozen time function with exception long t e action throw e synchronize lock final long timestamp before update freeze t result action apply timestamp before update final long timestamp after update unfreeze time check state timestamp after update timestamp before update timestamp before and after the update do not match return result private static long freeze if time be freeze last return processing time long min value time be frozen true return get current timestamp else return last return processing time override guard by lock public long current timestamp synchronize lock if time be freeze last return processing time long min value return last return processing time return get current timestamp guard by lock private static long get current timestamp final long current processing time system current time millis if current processing time last return processing time return last return processing time last return processing time current processing time return last return processing time private static long unfreeze time time be frozen false return last return processing time 
recoverable multi part upload impl internal not thread safe final class recoverable multi part upload impl implement recoverable multi part upload private final s3 access helper s3 access helper private final executor upload thread pool private final deque completable future part e tag upload in progress private final string name prefix for temp object private final multi part upload info current upload info private recoverable multi part upload impl s3 access helper s3 access helper executor upload thread pool string upload id string object name list part e tag part so far long num byte optional file incomplete part check argument num byte 0 l this s3 access helper check not null s3 access helper this upload thread pool check not null upload thread pool this current upload info new multi part upload info object name upload id part so far num byte incomplete part this name prefix for temp object create incomplete part object name prefix object name this upload in progress new array deque add a part to the upload without any size limitation p this method be non block and do not wait for the part upload to complete param file the file with the part data throw i o exception if this method throw a exception the recoverable s3 multi part upload should not be use any more but recover instead override public void upload part ref count f s output stream file throw i o exception this be to guarantee that nobody be write to the file we be uploading check state file be closed final completable future part e tag future new completable future upload in progress add future final long part length file get pos current upload info register new part part length file retain keep the file while the async upload still run upload thread pool execute new upload task s3 access helper current upload info file future override public optional file get incomplete part return current upload info get incomplete part override public s3 committer snapshot and get committer throw i o exception final s3 recoverable snapshot snapshot and get recoverable null return new s3 committer s3 access helper snapshot get object name snapshot upload id snapshot part snapshot num byte in part create a snapshot of this multi part upload from which the upload can be resume p datum buffer locally which be less than link org apache flink f s3 common flink s3 file system s3 multipart min part size s3 multipart min part size and can not be upload as part of the mpu and set to s3 as independent object p this implementation currently block until all part upload be complete and return a complete future override public s3 recoverable snapshot and get recoverable nullable final ref count f s output stream incomplete part file throw i o exception final string incomplete part object name safely upload small part incomplete part file make sure all other upload be complete this currently make the method block to be make non block in the future await pend part upload final string object name current upload info get object name final string upload id current upload info get upload id final list part e tag complete part current upload info get copy of etag of complete part final long size in byte current upload info get expect size in byte if incomplete part object name null return new s3 recoverable object name upload id complete part size in byte else return new s3 recoverable object name upload id complete part size in byte incomplete part object name incomplete part file get pos nullable private string safely upload small part nullable ref count f s output stream file throw i o exception if file null file get pos 0 l return null first upload the trail datum file during that time other in progress upload may complete final string incomplete part object name create incomplete part object name file retain try s3 access helper put object incomplete part object name file get input file finally file release return incomplete part object name util visible for test static string create incomplete part object name prefix string object name check not null object name final int last slash object name last index of final string parent final string child if last slash parent child object name else parent object name substring last slash child object name substring last slash return parent child be empty child tmp private string create incomplete part object name return name prefix for temp object uuid random u u i d to string private void await pend part upload throw i o exception check state current upload info get remain part upload in progress size while current upload info get remain part completable future part e tag next upload in progress peek first part e tag next part await pend part upload to complete next current upload info register complete part next part upload in progress remove first private part e tag await pend part upload to complete completable future part e tag upload throw i o exception final part e tag complete upload etag try complete upload etag upload get catch interrupted exception e thread current thread interrupt throw new i o exception interrupt while wait for part upload to complete catch execution exception e throw new i o exception uploading part fail e get cause return complete upload etag factory method public static recoverable multi part upload impl new upload final s3 access helper s3 access helper final executor upload thread pool final string object name throw i o exception final string multi part upload id s3 access helper start multi part upload object name return new recoverable multi part upload impl s3 access helper upload thread pool multi part upload id object name new array list 0 l optional empty public static recoverable multi part upload impl recover upload final s3 access helper s3 access helper final executor upload thread pool final string multipart upload id final string object name final list part e tag part so far final long num byte so far final optional file incomplete part return new recoverable multi part upload impl s3 access helper upload thread pool multipart upload id object name new array list part so far num byte so far incomplete part factory method private static class upload task implement runnable private final s3 access helper s3 access helper private final string object name private final string upload id private final int part number private final ref count f s output stream file private final completable future part e tag future upload task final s3 access helper s3 access helper final multi part upload info current upload final ref count f s output stream file final completable future part e tag future check not null current upload this object name current upload get object name this upload id current upload get upload id this part number current upload get number of registered part these be limit put by amazon check argument part number part number this s3 access helper check not null s3 access helper this file check not null file this future check not null future override public void run try final upload part result result s3 access helper upload part object name upload id part number file get input file file get pos future complete new part e tag result get part number result get e tag file release catch throwable t future complete exceptionally t 
s3 recoverable f datum output stream public evolve not thread safe public final class s3 recoverable f datum output stream extend recoverable f datum output stream lock that guard the critical section when new part be roll over despite the class be declare not thread safe we protect certain region to at least enable concurrent close call during cancellation or abort cleanup private final reentrant lock lock new reentrant lock private final recoverable multi part upload upload private final function with exception file ref count file with stream i o exception tmp file provider the number of byte at which we start a new part of the multipart upload this have to be greater than the non configurable minimum that be equal to link org apache flink f s3 common flink s3 file system s3 multipart min part size s3 multipart min part size and be set by amazon private final long user define min part size private ref count f s output stream file stream private long byte before current part single constructor to initialize all actual setup of the part happen in the factory method s3 recoverable f datum output stream recoverable multi part upload upload function with exception file ref count file with stream i o exception temp file creator ref count f s output stream initial tmp file long user define min part size long byte before current part check argument byte before current part 0 l this upload check not null upload this tmp file provider check not null temp file creator this user define min part size user define min part size this file stream initial tmp file this byte before current part byte before current part stream method override public void write int b throw i o exception file stream write b override public void write byte b int off int len throw i o exception file stream write b off len open new part if necessary user define min part size override public void flush throw i o exception file stream flush open new part if necessary user define min part size override public long get po throw i o exception return byte before current part file stream get po override public void sync throw i o exception file stream sync override public void close throw i o exception lock try file stream flush finally i o util close quietly file stream file stream release unlock recoverable stream method override public recoverable writer resume recoverable persist throw i o exception lock try file stream flush open new part if necessary user define min part size we do not stop write to the current file we merely limit the upload to the first n byte of the current file return upload snapshot and get recoverable file stream finally unlock override public committer close for commit throw i o exception lock try close and upload part return upload snapshot and get committer finally unlock s3 private void open new part if necessary long size threshold throw i o exception final long file length file stream get po if file length size threshold lock try upload current and open new part file length finally unlock private void upload current and open new part long file length throw i o exception byte before current part file length close and upload part initialize a new temp file file stream ref count buffer file stream open new tmp file provider private void close and upload part throw i o exception file stream flush file stream close if file stream get pos 0 l upload upload part file stream file stream release lock private void lock throw i o exception try lock lock interruptibly catch interrupted exception e thread current thread interrupt throw new i o exception interrupt private void unlock lock unlock factory method public static s3 recoverable f datum output stream new stream final recoverable multi part upload upload final function with exception file ref count file with stream i o exception tmp file creator final long user define min part size throw i o exception check argument user define min part size s3 multipart min part size final ref count buffer file stream file stream bound buffer file stream tmp file creator optional empty return new s3 recoverable f datum output stream upload tmp file creator file stream user define min part size 0 l public static s3 recoverable f datum output stream recover stream final recoverable multi part upload upload final function with exception file ref count file with stream i o exception tmp file creator final long user define min part size final long byte before current part throw i o exception check argument user define min part size s3 multipart min part size final ref count buffer file stream file stream bound buffer file stream tmp file creator upload get incomplete part return new s3 recoverable f datum output stream upload tmp file creator file stream user define min part size byte before current part private static ref count buffer file stream bound buffer file stream final function with exception file ref count file with stream i o exception tmp file creator final optional file incomplete part throw i o exception if incomplete part be present return ref count buffer file stream open new tmp file creator final file file incomplete part get return ref count buffer file stream restore tmp file creator file 
channel state checkpoint writer not thread safe class channel state checkpoint writer private static final logger log logger factory get logger channel state checkpoint writer class private final datum output stream datum stream private final checkpoint state output stream checkpoint stream private final channel state write result result private final map input channel info state content meta info input channel offset new hash map private final map result subpartition info state content meta info result subpartition offset new hash map private final channel state serializer serializer private final long checkpoint id private boolean all input receive false private boolean all output receive false private final runnable with exception on complete channel state checkpoint writer checkpoint start request start checkpoint item checkpoint stream factory stream factory channel state serializer serializer runnable with exception on complete throw exception this start checkpoint item get checkpoint id start checkpoint item get target result stream factory create checkpoint state output stream exclusive serializer on complete channel state checkpoint writer long checkpoint id channel state write result result checkpoint state output stream stream channel state serializer serializer runnable with exception on complete throw exception this checkpoint id result serializer on complete stream new datum output stream stream channel state checkpoint writer long checkpoint id channel state write result result channel state serializer serializer runnable with exception on complete checkpoint state output stream checkpoint state output stream datum output stream datum stream throw exception this checkpoint id checkpoint id this result check not null result this checkpoint stream check not null checkpoint state output stream this serializer check not null serializer this data stream check not null datum stream this on complete check not null on complete run with check serializer write header datum stream void write input input channel info info buffer buffer throw exception write input channel offset info buffer all input receive void write output result subpartition info info buffer buffer throw exception write result subpartition offset info buffer all output receive private k void write map k state content meta info offset k key buffer buffer boolean precondition throw exception try if result be do return run with check check state precondition long offset checkpoint stream get pos serializer write datum datum stream buffer long size checkpoint stream get po offset offset compute if absent key unused new state content meta info with datum add offset size finally buffer recycle buffer void complete input throw exception log debug complete input output complete all output receive complete all input receive all input receive true void complete output throw exception log debug complete output input complete all input receive complete all output receive all output receive true private void complete boolean precondition runnable with exception complete throw exception if result be do likely after abort only need to set the flag run on complete callback do complete precondition complete on complete else run with check do complete precondition complete on complete this finish write and result private void finish write and result throw i o exception if input channel offset be empty result subpartition offset be empty datum stream close result input channel state handle complete empty list result result subpartition state handle complete empty list return datum stream flush stream state handle underlie checkpoint stream close and get handle complete underlying result input channel state handle input channel offset handle factory input channel complete underlying result result subpartition state handle result subpartition offset handle factory result subpartition private void do complete boolean precondition runnable with exception complete runnable with exception callback throw exception precondition check argument precondition complete run if all input receive all output receive for runnable with exception callback callback callback run private i h extend abstract channel state handle i void complete stream state handle underlie completable future collection h future map i state content meta info offset handle factory i h handle factory throw i o exception final collection h handle new array list for map entry i state content meta info e offset entry set handle add create handle handle factory underlie e get key e get value future complete handle log debug channel state write complete checkpoint id handle checkpoint id handle private i h extend abstract channel state handle i h create handle handle factory i h handle factory stream state handle underlie i channel info state content meta info content meta info throw i o exception optional byte byte underlie as byte if in memory todo consider restructure channel state and remove this method http issue apache org jira browse flink if byte be present stream state handle extract new byte stream state handle random u u i d to string serializer extract and merge byte get content meta info get offset return handle factory create channel info extract singleton list serializer get header length extract get state size else return handle factory create channel info underlie content meta info get offset content meta info get size private void run with check runnable with exception r throw exception try check state result be do result be already complete result r run catch exception e fail e throw e public void fail throwable e throw exception result fail e checkpoint stream close private interface handle factory i h extend abstract channel state handle i h create i info stream state handle underlie list long offset long size handle factory input channel info input channel state handle input channel input channel state handle new handle factory result subpartition info result subpartition state handle result subpartition result subpartition state handle new 
channel state reader impl not thread safe internal public class channel state reader impl implement channel state reader private static final logger log logger factory get logger channel state reader impl class private final map input channel info channel state stream reader input channel handle reader private final map result subpartition info channel state stream reader result subpartition handle reader private boolean be closed false public channel state reader impl task state snapshot snapshot this snapshot new channel state serializer impl channel state reader impl task state snapshot snapshot channel state serializer serializer ref count f s datum input stream factory stream factory new ref count f s datum input stream factory serializer final hash map input channel info channel state stream reader input channel handle reader tmp new hash map final hash map result subpartition info channel state stream reader result subpartition handle reader tmp new hash map for map entry operator i d operator subtask state e snapshot get subtask state mapping add reader input channel handle reader tmp e get value get input channel state stream factory add reader result subpartition handle reader tmp e get value get result subpartition state stream factory input channel handle reader input channel handle reader tmp memory barrier to allow another thread call clear result subpartition handle reader result subpartition handle reader tmp memory barrier to allow another thread call clear private t void add reader map t channel state stream reader reader map collection extend abstract channel state handle t handle ref count f s datum input stream factory stream factory for abstract channel state handle t handle handle check state reader map contain key handle get info multiple state exist for channel handle get info reader map put handle get info new channel state stream reader handle stream factory override public boolean have channel state return input channel handle reader be empty result subpartition handle reader be empty override public read result read input datum input channel info info buffer buffer throw i o exception precondition check state be closed reader be closed log debug read input datum result subpartition info buffer info buffer channel state stream reader reader input channel handle reader get info return reader null read result no more datum reader read into buffer override public read result read output datum result subpartition info info buffer builder buffer builder throw i o exception precondition check state be closed reader be closed log debug read output datum result subpartition info buffer builder info buffer builder channel state stream reader reader result subpartition handle reader get info return reader null read result no more datum reader read into buffer builder override public void close throw exception be closed true try closer closer closer create for map channel state stream reader map as list input channel handle reader result subpartition handle reader for channel state stream reader reader map value closer register reader map clear 
channel state serializer internal not thread safe interface channel state byte buffer boolean be writable read up to code byte to read code byte into this buffer from the give link input stream return the total number of byte read into this buffer int write byte input stream input int byte to read throw i o exception static channel state byte buffer wrap buffer buffer return new channel state byte buffer private final byte buf byte buf buffer as byte buf override public boolean be writable return byte buf be writable override public int write byte input stream input int byte to read throw i o exception return byte buf write byte input math min byte to read byte buf writable byte static channel state byte buffer wrap buffer builder buffer builder final byte buf new byte return new channel state byte buffer override public boolean be writable return buffer builder be full override public int write byte input stream input int byte to read throw i o exception int leave byte to read for int to read get to read leave to read to read get to read left int read input read buf to read int copy buffer builder append java nio byte buffer wrap buf read precondition check state copy read left read buffer builder commit return byte to read left private int get to read int byte to read return min byte to read min buf length buffer builder get writable byte static channel state byte buffer wrap byte byte return new channel state byte buffer private int write override public boolean be writable return write byte length override public int write byte input stream input int byte to read throw i o exception final int byte read input read byte write byte length write write byte read return byte read 
channel state stream reader not thread safe class channel state stream reader implement closeable private final ref count f s datum input stream stream private final channel state serializer serializer private final queue long offset private int remain byte private boolean closed false channel state stream reader abstract channel state handle handle ref count f s datum input stream factory stream factory this stream factory get or create handle handle get offset stream factory get serializer private channel state stream reader ref count f s datum input stream stream list long offset channel state serializer serializer this stream stream this stream inc ref this serializer serializer this offset new link list offset read result read into buffer buffer throw i o exception return read into wrap buffer read result read into buffer builder buffer builder throw i o exception return read into wrap buffer builder private read result read into channel state byte buffer buffer throw i o exception precondition check state closed reader be closed read while possible buffer if have more datum return have more datum else close true stream dec ref return no more datum private void read while possible channel state byte buffer buffer throw i o exception while have more datum buffer be writable if remain byte advance offset int byte read serializer read datum stream buffer remain byte remain byte byte read private boolean have more datum return remain byte offset be empty suppress warning constant condition private void advance offset throw i o exception stream seek offset poll remain byte serializer read length stream override public void close throw i o exception if close closed true stream close 
ref count f s datum input stream not thread safe class ref count f s datum input stream extend f s datum input stream private enum state new open closed private final supplier with exception f s datum input stream i o exception stream supplier private f s datum input stream stream private final channel state serializer serializer private int ref count private state state state new private ref count f s datum input stream supplier with exception f s datum input stream i o exception stream supplier channel state serializer serializer this stream supplier check not null stream supplier this serializer check not null serializer void inc ref check not close ref count void dec ref throw i o exception check not close ref count if ref count close override public int read throw i o exception ensure open return stream read override public void seek long po throw i o exception ensure open stream seek po override public long get po throw i o exception ensure open return stream get pos public void close throw i o exception state state close if stream null stream close stream null private void ensure open throw i o exception check not close if state state new stream precondition check not null stream supplier get serializer read header stream state state open private void check not closed check state state state close stream be close not thread safe static class ref count f s datum input stream factory private final map stream state handle ref count f s datum input stream stream new hash map not clear expect short life private final channel state serializer serializer ref count f s datum input stream factory channel state serializer serializer this serializer check not null serializer t ref count f s datum input stream get or create abstract channel state handle t handle stream state handle stream state handle handle get delegate ref count f s datum input stream stream stream get stream state handle if stream null stream new ref count f s datum input stream stream state handle open input stream serializer stream put stream state handle stream return stream channel state serializer get serializer return serializer 
ref count f s datum input stream not thread safe static class ref count f s datum input stream factory private final map stream state handle ref count f s datum input stream stream new hash map not clear expect short life private final channel state serializer serializer ref count f s datum input stream factory channel state serializer serializer this serializer check not null serializer t ref count f s datum input stream get or create abstract channel state handle t handle stream state handle stream state handle handle get delegate ref count f s datum input stream stream stream get stream state handle if stream null stream new ref count f s datum input stream stream state handle open input stream serializer stream put stream state handle stream return stream channel state serializer get serializer return serializer 
buffer builder not thread safe public class buffer builder private final memory segment memory segment private final buffer recycler recycler private final settable position marker position marker new settable position marker private boolean buffer consumer create false public buffer builder memory segment memory segment buffer recycler recycler this memory segment check not null memory segment this recycler check not null recycler this method always create a link buffer consumer start from the current writer offset datum write to link buffer builder before creation of link buffer consumer win t be visible for that link buffer consumer return create match instance of link buffer consumer to this link buffer builder public buffer consumer create buffer consumer check state buffer consumer create two buffer consumer shouldn t exist for one buffer builder buffer consumer create true return new buffer consumer memory segment recycler position marker position marker cache position same as link append byte buffer but additionally link commit the append public int append and commit byte buffer source int write byte append source commit return write byte append as many datum as possible from code source not everything might be copy if there be not enough space in the underlie link memory segment return number of copy byte public int append byte buffer source check state be finish int need source remain int available get max capacity position marker get cache int to copy math min need available memory segment put position marker get cache source to copy position marker move to copy return to copy make the change visible to the reader this be costly operation volatile access thus in case of bulk write it be better to commit they all together instead one by one public void commit position marker commit mark this link buffer builder and associate link buffer consumer as finish no new datum write will be allow p this method should be idempotent to handle failure and task interruption check flink for more detail return number of write byte public int finish int write byte position marker mark finish commit return write byte public boolean be finish return position marker be finish public boolean be full check state position marker get cache get max capacity return position marker get cache get max capacity public int get writable byte check state position marker get cache get max capacity return get max capacity position marker get cache public int get commit byte return position marker get cache public int get max capacity return memory segment size visible for test public buffer recycler get recycler return recycler visible for test public memory segment get memory segment return memory segment hold a reference to the current writer position negative value indicate that writer link buffer builder have finish value code integer min value represent finished empty buffer thread safe interface position marker int finish empty integer min value int get static boolean be finish int position return position static int get absolute int position if position finish empty return return math abs position cache write implementation of link position marker p writer link buffer builder and reader link buffer consumer cache must be implement independently of one another so that the cached value can not accidentally leak from one to another p remember to commit the link settable position marker to make the change visible static class settable position marker implement position marker private volatile int position locally cache value of volatile code position to avoid unnecessary volatile access private int cache position override public int get return position public boolean be finish return position marker be finish cache position public int get cache return position marker get absolute cache position mark this position as finish and return the current position return current position as of link get cache public int mark finish int current position get cache int new value current position if new value new value finish empty set new value return current position public void move int offset set cache position offset public void set int value cache position value public void commit position cache position 
buffer consumer not thread safe public class buffer consumer implement closeable private final buffer buffer private final cache position marker writer position private int current reader position construct link buffer consumer instance with the initial reader position public buffer consumer memory segment memory segment buffer recycler recycler position marker current writer position int current reader position this new network buffer check not null memory segment check not null recycler current writer position current reader position construct link buffer consumer instance with static content public buffer consumer memory segment memory segment buffer recycler recycler buffer datum type datum type this memory segment recycler memory segment size datum type construct link buffer consumer instance with static content of a certain size public buffer consumer memory segment memory segment buffer recycler recycler int size buffer datum type datum type this new network buffer check not null memory segment check not null recycler datum type size check state memory segment size check state be finish buffer consumer with static size must be finish after construction private buffer consumer buffer buffer buffer builder position marker current writer position int current reader position this buffer check not null buffer this writer position new cache position marker check not null current writer position check argument current reader position writer position get cache reader position larger than writer position this current reader position current reader position check whether the link buffer builder have already be finish p beware this method access the cached value of the position marker which be only update after call to link build return tt true tt if the buffer be finish tt false tt otherwise public boolean be finish return writer position be finished return slice link buffer contain the not yet consume datum return link buffer share the reference counter with the parent link buffer consumer in order to recycle memory both of they must be recycle closed public buffer build writer position update int cache writer position writer position get cache buffer slice buffer read only slice current reader position cache writer position current reader position current reader position cache writer position return slice retain buffer return a retain copy with separate index this allow to read from the same link memory segment twice p warn the newly return link buffer consumer will have its reader index copy from the original buffer in other word datum already consume before copying will not be visible to the return copy return a retain copy of self with separate index public buffer consumer copy return new buffer consumer buffer retain buffer writer position position marker current reader position return a retain copy with separate index and set the reader position to the give value this allow to read from the same link memory segment twice start from the supply position param reader position the new reader position can be less than the link current reader position but may not exceed the current writer s position return a retain copy of self with separate index public buffer consumer copy with reader position int reader position return new buffer consumer buffer retain buffer writer position position marker reader position public boolean be buffer return buffer be buffer override public void close if buffer be recycled buffer recycle buffer public boolean be recycled return buffer be recycle public int get write byte return writer position get cache int get current reader position return current reader position return true if there be new datum available for read public boolean be datum available return current reader position writer position get latest cached reading wrapper around link position marker p writer link buffer builder and reader link buffer consumer cache must be implement independently of one another so that the cached value can not accidentally leak from one to another private static class cache position marker private final position marker position marker locally cache value of link position marker to avoid unnecessary volatile access private int cache position cache position marker position marker position marker this position marker check not null position marker update public boolean be finish return position marker be finish cache position public int get cache return position marker get absolute cache position private int get latest return position marker get absolute position marker get private void update this cache position position marker get 
state snapshot transformer functional interface not thread safe public interface state snapshot transformer t transform or filter out state value which be include or skip in the snapshot param value non serialize form of value return value to snapshot or null which mean the entry be not include nullable t filter or transform nullable t value collection state specific transformer which say how to transform entry of the collection interface collection state snapshot transformer t extend state snapshot transformer t enum transform strategy transform all entry transform all skip first null entry p while traverse collection entry as optimisation stop transform if encounter first non null include entry and return it plus the rest untouched stop on first include default transform strategy get filter strategy return transform strategy transform all this factory create state transformer depend on the form of value to transform p if there be no transform need the factory method return code optional empty interface state snapshot transform factory t state snapshot transform factory no transform create no transform suppress warning unchecked static t state snapshot transform factory t no transform return state snapshot transform factory t no transform static t state snapshot transform factory t create no transform return new state snapshot transform factory t override public optional state snapshot transformer t create for deserialize state return optional empty override public optional state snapshot transformer byte create for serialize state return optional empty optional state snapshot transformer t create for deserialize state optional state snapshot transformer byte create for serialize state 
task manager runner configuration test not thread safe public class task manager runner configuration test extend test logger private static final int test timeout seconds rule public temporary folder temporary folder new temporary folder test public void test task manager rpc service should bind to configure task manager hostname throw exception final string taskmanager host testhostname final configuration config create flink config with predefined task manager hostname taskmanager host final high availability service high availability service create high availability service config rpc service task manager rpc service null try task manager rpc service task manager runner create rpc service config high availability service assert that task manager rpc service get port be greater than or equal to assert that task manager rpc service get address be equal to taskmanager host finally maybe close rpc service task manager rpc service high availability service close and cleanup all datum test public void test task manager rpc service should bind to hostname address throw exception final configuration config create flink config with host bind policy host bind policy name final high availability service high availability service create high availability service config rpc service task manager rpc service null try task manager rpc service task manager runner create rpc service config high availability service assert that task manager rpc service get address not be empty or null string finally maybe close rpc service task manager rpc service high availability service close and cleanup all datum test public void test task manager rpc service should bind to ip address determine by connect to resource manager throw exception final server socket test job manager socket open server socket final configuration config create flink config with job manager port test job manager socket get local port final high availability service high availability service create high availability service config rpc service task manager rpc service null try task manager rpc service task manager runner create rpc service config high availability service assert that task manager rpc service get address be ip address finally maybe close rpc service task manager rpc service high availability service close and cleanup all datum i o util close quietly test job manager socket test public void test create task manager rpc service should fail if rpc port range be invalid throw exception final configuration config new configuration create flink config with predefined task manager hostname example org config set string task manager option rpc port final high availability service high availability service create high availability service config try task manager runner create rpc service config high availability service fail should fail because be not a valid port range catch final illegal argument exception e assert that e get message contain string invalid port range definition finally high availability service close and cleanup all datum test public void test default f parameter loading throw exception try final file tmp dir temporary folder new folder final file conf file new file tmp dir global configuration flink conf filename final uri default f s new uri other f s null localhost null null null final print writer pw1 new print writer conf file pw1 println f default scheme default f s pw1 close string arg new string config dir tmp dir to string configuration configuration task manager runner load configuration arg file system initialize configuration assert equal default f s file system get default f uri finally reset f setting file system initialize new configuration test public void test load dynamical property throw i o exception flink parse exception final file tmp dir temporary folder new folder final file conf file new file tmp dir global configuration flink conf filename final print writer pw1 new print writer conf file final long manage memory pw1 println job manager option address key localhost pw1 println task manager option manage memory size key manage memory b pw1 close final string jm host host1 final int jm port string arg new string config dir tmp dir to string d job manager option address key jm host d job manager option port key jm port configuration configuration task manager runner load configuration arg assert equal memory size parse manage memory b configuration get task manager option manage memory size assert equal jm host configuration get job manager option address assert equal jm port configuration get integer job manager option port private static configuration create flink config with predefined task manager hostname final string taskmanager host final configuration config new configuration config set string task manager option host taskmanager host config set string job manager option address localhost return new unmodifiable configuration config private static configuration create flink config with host bind policy final host bind policy bind policy final configuration config new configuration config set string task manager option host bind policy bind policy to string config set string job manager option address localhost config set string akka option lookup timeout ms return new unmodifiable configuration config private static configuration create flink config with job manager port final int port configuration config new configuration config set string job manager option address localhost config set integer job manager option port port return new unmodifiable configuration config private high availability service create high availability service final configuration config throw exception return high availability service util create high availability service config executor direct executor high availability service util address resolution no address resolution private static server socket open server socket try return new server socket catch i o exception e assume no exception skip test because could not open a server socket e throw new runtime exception satisfy compiler private static void maybe close rpc service nullable final rpc service rpc service throw exception if rpc service null rpc service stop service get test timeout seconds time unit seconds private static type safe matcher string ip address return new type safe matcher string override protect boolean match safely string value return i p address util be i pv4 literal address value i p address util be i pv6 literal address value override public void describe to description description description append text be a ip address 
rock d b serialize composite key builder not thread safe internal class rock d b serialize composite key builder k the serializer for the key nonnull private final type serializer k key serializer the output to write the key into nonnull private final datum output serializer key out view the number of key group prefix byte for the key nonnegative private final int key group prefix byte this flag indicate whether the key type have a variable byte size in serialization private final boolean key serializer type variable sized mark for the position after the serialize key nonnegative private int after key mark public rock d b serialize composite key builder nonnull type serializer k key serializer nonnegative int key group prefix byte nonnegative int initial size this key serializer new datum output serializer initial size key group prefix byte rock d b key serialization util be serializer type variable sized key serializer visible for test rock d b serialize composite key builder nonnull type serializer k key serializer nonnull datum output serializer key out view nonnegative int key group prefix byte boolean key serializer type variable sized nonnegative int after key mark this key serializer key serializer this key out view key out view this key group prefix byte key group prefix byte this key serializer type variable sized key serializer type variable sized this after key mark after key mark set the key and key group as prefix this will serialize they into the buffer and the will be use to create composite key with provide namespace param key the key param key group id the key group id for the key public void set key and key group nonnull k key nonnegative int key group id try serialize key group and key key key group id catch i o exception should never happen throw new flink runtime exception should never happen return a serialized composite key from the key and key group provide in a previous call to link set key and key group object int and the give namespace param namespace the namespace to concatenate for the serialize composite key byte param namespace serializer the serializer to obtain the serialize form of the namespace param n the type of the namespace return the byte for the serialize composite key of key group key namespace nonnull public n byte build composite key namespace nonnull n namespace nonnull type serializer n namespace serializer try serialize namespace namespace namespace serializer final byte result key out view get copy of buffer reset to key return result catch i o exception should never happen throw new flink runtime exception should never happen return a serialized composite key from the key and key group provide in a previous call to link set key and key group object int and the give namespace folloe by the give user key param namespace the namespace to concatenate for the serialize composite key byte param namespace serializer the serializer to obtain the serialize form of the namespace param user key the user key to concatenate for the serialize composite key after the namespace param user key serializer the serializer to obtain the serialize form of the user key param n the type of the namespace param uk the type of the user key return the byte for the serialize composite key of key group key namespace nonnull public n uk byte build composite key name space user key nonnull n namespace nonnull type serializer n namespace serializer nonnull uk user key nonnull type serializer uk user key serializer throw i o exception serialize namespace namespace namespace serializer user key serializer serialize user key key out view byte result key out view get copy of buffer reset to key return result private void serialize key group and key k key int key group id throw i o exception clear buffer and mark reset fully write key group rock d b key serialization util write key group key group id key group prefix byte key out view write key key serializer serialize key key out view after key mark key out view length private n void serialize namespace nonnull n namespace nonnull type serializer n namespace serializer throw i o exception this should only be call when there be already a key write so that we build the composite assert be key write final boolean ambiguous composite key possible be ambiguous composite key possible namespace serializer if ambiguous composite key possible rock d b key serialization util write variable int byte after key mark key group prefix byte key out view rock d b key serialization util write name space namespace namespace serializer key out view ambiguous composite key possible private void reset fully after key mark key out view clear private void reset to key key out view set position after key mark private boolean be key written return after key mark visible for test boolean be ambiguous composite key possible type serializer namespace serializer return key serializer type variable sized rock d b key serialization util be serializer type variable sized namespace serializer 
checkpoint barrier unaligner internal not thread safe public class checkpoint barrier unaligner extend checkpoint barrier handler private static final logger log logger factory get logger checkpoint barrier unaligner class private final string task name tag the state of which input channel have pend in flight buffer that be already receive buffer that predate the checkpoint barrier of the current checkpoint private final map input channel info boolean have inflight buffer private int num barrier consume the checkpoint id to guarantee that we would trigger only one checkpoint when read the same barrier from different channel p note this checkpoint be valid in respect to b consume b barrier in contrast to link thread safe unaligner current receive checkpoint id private long current consume checkpoint id 1 l encapsulate state that be share between netty thread and task thread private final thread safe unaligner thread safe unaligner checkpoint barrier unaligner subtask checkpoint coordinator checkpoint coordinator string task name abstract invokable to notify on checkpoint input gate input gate super to notify on checkpoint this task name task name have inflight buffer array stream input gate flat map gate gate get channel info stream collect collector to map function identity info false thread safe unaligner new thread safe unaligner check not null checkpoint coordinator this input gate we still need to trigger checkpoint via link thread safe unaligner notify barrier receive checkpoint barrier input channel info while read the first barrier from one channel because this might happen earlier than the previous async trigger via mailbox by netty thread p note this be also suitable for the trigger case of local input channel override public void process barrier checkpoint barrier receive barrier input channel info channel info throw exception long barrier id receive barrier get id if current consume checkpoint id barrier id current consume checkpoint id barrier id be checkpoint pend ignore old and cancel barrier return if current consume checkpoint id barrier id current consume checkpoint id barrier id num barrier consume have inflight buffer entry set for each have inflight buffer have inflight buffer set value true if current consume checkpoint id barrier id have inflight buffer put channel info false num barrier consume thread safe unaligner notify barrier receive receive barrier channel info override public void abort pend checkpoint long checkpoint id checkpoint exception exception throw i o exception thread safe unaligner try abort pend checkpoint checkpoint id exception if checkpoint id current consume checkpoint id reset pend checkpoint checkpoint id override public void process cancellation barrier cancel checkpoint marker cancel barrier throw exception final long cancel id cancel barrier get checkpoint id boolean should abort thread safe unaligner set cancel checkpoint id cancel id if should abort notify abort cancel id new checkpoint exception checkpoint failure reason checkpoint decline on cancellation barrier if cancel id current consume checkpoint id reset pend checkpoint cancel id current consume checkpoint id cancel id override public void process end of partition throw exception thread safe unaligner on channel close reset pending checkpoint 1 l private void reset pend checkpoint long checkpoint id if be checkpoint pending log warn receive barrier or end of partition before complete current checkpoint skip current checkpoint task name checkpoint id current consume checkpoint id have inflight buffer entry set for each have inflight buffer have inflight buffer set value false num barrier consume override public long get latest checkpoint id return current consume checkpoint id override public string to string return string format s last checkpoint d task name current consume checkpoint id override public void close throw i o exception super close thread safe unaligner close override public boolean have inflight datum long checkpoint id input channel info channel info if checkpoint id current consume checkpoint id return false if checkpoint id current consume checkpoint id return true return have inflight buffer get channel info override public completable future void get all barrier receive future long checkpoint id return thread safe unaligner get all barrier receive future checkpoint id override public optional buffer receive listener get buffer receive listener return optional of thread safe unaligner override protect boolean be checkpoint pend return num barrier consume visible for test int get num open channel return thread safe unaligner get num open channel visible for test thread safe unaligner get thread safe unaligner return thread safe unaligner private void notify checkpoint checkpoint barrier barrier throw i o exception ignore the previous trigger checkpoint by netty thread if it be already cancel or abort before if barrier get id thread safe unaligner get current checkpoint id super notify checkpoint barrier thread safe static class thread safe unaligner implement buffer receive listener closeable tag the state of which input channel have not receive the barrier such that newly arrive buffer need to be write in the unaligned checkpoint private final map input channel info boolean store new buffer the number of input channel which have receive or process the barrier private int num barrier receive a future indicate that all barrier of the a give checkpoint have be read private completable future void all barrier receive future future util complete void future the checkpoint id to guarantee that we would trigger only one checkpoint when read the same barrier from different channel p note this checkpoint be valid in respect to b receive b barrier in contrast to link checkpoint barrier unaligner current consume checkpoint id private long current receive checkpoint id 1 l private int num open channel private final subtask checkpoint coordinator checkpoint coordinator private final checkpoint barrier unaligner handler thread safe unaligner subtask checkpoint coordinator checkpoint coordinator checkpoint barrier unaligner handler input gate input gate store new buffer array stream input gate flat map gate gate get channel info stream collect collector to map function identity info false num open channel store new buffer size this checkpoint coordinator checkpoint coordinator this handler handler override public synchronize void notify barrier receive checkpoint barrier barrier input channel info channel info throw i o exception long barrier id barrier get id if current receive checkpoint id barrier id handle new checkpoint barrier handler execute in task thread handler notify checkpoint barrier notify checkpoint if barrier id current receive checkpoint id store new buffer get channel info if log be debug enable log debug receive barrier from channel handler task name channel info barrier id store new buffer put channel info false if num barrier receive num open channel all barrier receive future complete null override public synchronize void notify buffer receive buffer buffer input channel info channel info if store new buffer get channel info checkpoint coordinator get channel state writer add input datum current receive checkpoint id channel info channel state writer sequence number unknown of element buffer buffer recycle buffer else buffer recycle buffer override public synchronize void close throw i o exception all barrier receive future cancel false private synchronize void handle new checkpoint checkpoint barrier barrier throw i o exception long barrier id barrier get id if all barrier receive future be do checkpoint exception exception new checkpoint exception barrier id barrier id checkpoint decline subsume if be checkpoint pend we do not complete the current checkpoint another start before log warn receive checkpoint barrier for checkpoint before complete current checkpoint skip current checkpoint handler task name barrier id current receive checkpoint id let the task know we be not complete this final long current checkpoint id current receive checkpoint id handler execute in task thread handler notify abort current checkpoint id exception notify abort all barrier receive future complete exceptionally exception current receive checkpoint id barrier id store new buffer entry set for each store new buffer store new buffer set value true num barrier receive all barrier receive future new completable future checkpoint coordinator init checkpoint barrier id barrier get checkpoint option synchronize completable future void get all barrier receive future long checkpoint id if checkpoint id current receive checkpoint id return future util complete void future if checkpoint id current receive checkpoint id throw new illegal state exception checkpoint checkpoint id have not be start at all return all barrier receive future synchronize void on channel close throw i o exception num open channel if reset pending checkpoint handler notify abort current receive checkpoint id new checkpoint exception checkpoint failure reason checkpoint decline input end of stream synchronize boolean set cancel checkpoint id long cancel id if current receive checkpoint id cancel id current receive checkpoint id cancel id num barrier receive return false reset pend checkpoint current receive checkpoint id cancel id return true synchronize void try abort pend checkpoint long checkpoint id checkpoint exception exception throw i o exception if checkpoint id current receive checkpoint id reset pend checkpoint handler notify abort current receive checkpoint id exception private boolean reset pend checkpoint if num barrier receive return false store new buffer entry set for each store new buffer store new buffer set value false num barrier receive return true visible for test synchronize int get num open channel return num open channel visible for test synchronize long get current checkpoint id return current receive checkpoint id visible for test boolean be checkpoint pend return num barrier receive 
