handover thread safe internal public final class handover implement closeable private final object lock new object private consumer record byte byte next private throwable error private boolean wakeup producer poll the next element from the handover possibly block until the next element be available this method behave similar to polling from a block queue p if a exception be hand in by the producer link report error throwable then that exception be throw rather than a element be return return the next element buffer of record never null throw closed exception throw if the handover be link close close throw exception rethrow exception from the link report error throwable method nonnull public consumer record byte byte poll next throw exception synchronize lock while next null error null lock wait consumer record byte byte n next if n null next null lock notify all return n else exception util rethrow exception error error get message this statement can not be reach since the above method always throw a exception this be only here to silence the compiler and any warning return consumer record empty hand over a element from the producer if the handover already have a element that be not yet pick up by the consumer thread this call block until the consumer pick up that previous element p this behavior be similar to a size one block queue param element the next element to hand over throw interrupted exception throw if the thread be interrupt while block for the handover to be empty throw wakeup exception throw if the link wakeup producer method be call while block for the handover to be empty throw closed exception throw if the handover be close or concurrently be close public void produce final consumer record byte byte element throw interrupted exception wakeup exception close exception check not null element synchronize lock while next null wakeup producer lock wait wakeup producer false if there be still a element we must have be wake up if next null throw new wakeup exception if there be no error then this be open and can accept this element else if error null next element lock notify all a error mark this as close for the producer else throw new closed exception report a exception the consumer will throw the give exception immediately if it be currently block in the link poll next method or the next time it call that method p after this method have be call no call to either link produce consumer record or link poll next will ever return regularly any more but will always return exceptionally p if another exception be already report this method do nothing p for the producer the handover will appear as if it be link close close param t the exception to report public void report error throwable t check not null t synchronize lock do not override the initial exception if error null error t next null lock notify all close the handover both the link produce consumer record method and the link poll next will throw a link close exception on any currently block and future invocation p if a exception be previously report via the link report error throwable method that exception will not be override the consumer thread will throw that exception upon call link poll next rather than the code close exception override public void close synchronize lock next null wakeup producer false if error null error new closed exception lock notify all wake the producer thread up if the producer thread be currently block in the link produce consumer record method it will exit the method throw a link wakeup exception public void wakeup producer synchronize lock wakeup producer true lock notify all a exception throw by the handover in the link poll next or link produce consumer record method after the handover be close via link close public static final class close exception extend exception private static final long serial version u i d 1 l a special exception throw bv the handover in the link produce consumer record method when the producer be wake up from a block call via link wakeup producer public static final class wakeup exception extend exception private static final long serial version u i d 1 l 
handover thread safe internal public final class handover implement closeable private final object lock new object private consumer record byte byte next private throwable error private boolean wakeup producer poll the next element from the handover possibly block until the next element be available this method behave similar to polling from a block queue p if a exception be hand in by the producer link report error throwable then that exception be throw rather than a element be return return the next element buffer of record never null throw closed exception throw if the handover be link close close throw exception rethrow exception from the link report error throwable method nonnull public consumer record byte byte poll next throw exception synchronize lock while next null error null lock wait consumer record byte byte n next if n null next null lock notify all return n else exception util rethrow exception error error get message this statement can not be reach since the above method always throw a exception this be only here to silence the compiler and any warning return consumer record empty hand over a element from the producer if the handover already have a element that be not yet pick up by the consumer thread this call block until the consumer pick up that previous element p this behavior be similar to a size one block queue param element the next element to hand over throw interrupted exception throw if the thread be interrupt while block for the handover to be empty throw wakeup exception throw if the link wakeup producer method be call while block for the handover to be empty throw closed exception throw if the handover be close or concurrently be close public void produce final consumer record byte byte element throw interrupted exception wakeup exception close exception check not null element synchronize lock while next null wakeup producer lock wait wakeup producer false if there be still a element we must have be wake up if next null throw new wakeup exception if there be no error then this be open and can accept this element else if error null next element lock notify all a error mark this as close for the producer else throw new closed exception report a exception the consumer will throw the give exception immediately if it be currently block in the link poll next method or the next time it call that method p after this method have be call no call to either link produce consumer record or link poll next will ever return regularly any more but will always return exceptionally p if another exception be already report this method do nothing p for the producer the handover will appear as if it be link close close param t the exception to report public void report error throwable t check not null t synchronize lock do not override the initial exception if error null error t next null lock notify all close the handover both the link produce consumer record method and the link poll next will throw a link close exception on any currently block and future invocation p if a exception be previously report via the link report error throwable method that exception will not be override the consumer thread will throw that exception upon call link poll next rather than the code close exception override public void close synchronize lock next null wakeup producer false if error null error new closed exception lock notify all wake the producer thread up if the producer thread be currently block in the link produce consumer record method it will exit the method throw a link wakeup exception public void wakeup producer synchronize lock wakeup producer true lock notify all a exception throw by the handover in the link poll next or link produce consumer record method after the handover be close via link close public static final class close exception extend exception private static final long serial version u i d 1 l a special exception throw bv the handover in the link produce consumer record method when the producer be wake up from a block call via link wakeup producer public static final class wakeup exception extend exception private static final long serial version u i d 1 l 
default plugin manager internal thread safe public class default plugin manager implement plugin manager parent classloader to all classloader that be use for plugin loading we expect that this be thread safe private final class loader parent class loader a collection of description of all plugin know to this plugin manager private final collection plugin descriptor plugin descriptor list of pattern for class that should always be resolve from the parent class loader private final string always parent first pattern visible for test default plugin manager parent class loader null plugin descriptor null always parent first pattern null public default plugin manager collection plugin descriptor plugin descriptor string always parent first pattern this plugin descriptor default plugin manager class get class loader always parent first pattern public default plugin manager collection plugin descriptor plugin descriptor class loader parent class loader string always parent first pattern this plugin descriptor plugin descriptor this parent class loader parent class loader this always parent first pattern always parent first pattern override public p iterator p load class p service array list iterator p combine iterator new array list plugin descriptor size for plugin descriptor plugin descriptor plugin descriptor plugin loader plugin loader plugin loader create plugin descriptor parent class loader always parent first pattern combine iterator add plugin loader load service return iterator concat combine iterator iterator override public string to string return plugin manager parent class loader parent class loader plugin descriptor plugin descriptor always parent first pattern array to string always parent first pattern 
plugin loader thread safe public class plugin loader classloader which be use to load the plugin class we expect this classloader be thread safe private final class loader plugin class loader visible for test public plugin loader class loader plugin class loader this plugin class loader plugin class loader visible for test public static class loader create plugin class loader plugin descriptor plugin descriptor class loader parent class loader string always parent first pattern return new plugin class loader plugin descriptor get plugin resource u be l parent class loader array util concat always parent first pattern plugin descriptor get loader exclude pattern public static plugin loader create plugin descriptor plugin descriptor class loader parent class loader string always parent first pattern return new plugin loader create plugin class loader plugin descriptor parent class loader always parent first pattern return in iterator over all available implementation of the given service interface spi for the plugin param service the service interface spi for which implementation be request param p type of the request plugin service return a iterator of all implementation of the given service interface that could be load from the plugin public p iterator p load class p service try temporary class loader context ignore temporary class loader context of plugin class loader return new context class loader set iterator service loader load service plugin class loader iterator plugin class loader wrapper for the service iterator the wrapper will set unset the context classloader to the plugin classloader around the point where element be return param p type of the iterate plugin element static class context class loader set iterator p implement iterator p private final iterator p delegate private final class loader plugin class loader context class loader set iterator iterator p delegate class loader plugin class loader this delegate delegate this plugin class loader plugin class loader override public boolean have next return delegate have next override public p next try temporary class loader context ignore temporary class loader context of plugin class loader return delegate next load all class from the plugin jar except for explicitly white list package org apache flink log p no class resource in the system class loader everything in lib can be see in the plugin except those start with a whitelist prefix private static final class plugin class loader extend u be l class loader private static final class loader platform or bootstrap loader private final class loader flink class loader private final string allow flink package private final string allow resource prefix plugin class loader url plugin resource u r l class loader flink class loader string allow flink package super plugin resource u be l platform or bootstrap loader this flink class loader flink class loader this allow flink package allow flink package allow resource prefix array stream allow flink package map package name package name replace to array string new override protect class load class final string name final boolean resolve throw class not find exception synchronize get class loading lock name final class load class find loaded class name if load class null return resolve if need resolve load class if be allow flink class name try return resolve if need resolve flink class loader load class name catch class not find exception e fallback to resolve it in this classloader for case where the plugin use org apache flink namespace return super load class name resolve private class resolve if need final boolean resolve final class load class if resolve resolve class load class return load class override public url get resource final string name if be allow flink resource name return flink class loader get resource name return super get resource name override public enumeration url get resource final string name throw i o exception child first class loader merge child and parent resource if be allow flink resource name return flink class loader get resource name return super get resource name private boolean be allow flink class final string name return array stream allow flink package any match name start with private boolean be allow flink resource final string name return array stream allow resource prefix any match name start with static class loader platform loader null try platform loader class loader class loader class get method get platform class loader invoke null catch no such method exception e on java this method do not exist but use null indicate the bootstrap loader that we want to have catch exception e throw new illegal state exception can not retrieve platform classloader on java e platform or bootstrap loader platform loader 
channel state write request executor impl thread safe class channel state write request executor impl implement channel state write request executor private static final logger log logger factory get logger channel state write request executor impl class private static final int default handover capacity private final channel state write request dispatcher dispatcher private final blocking deque channel state write request deque private final thread thread private volatile exception throw null private volatile boolean be closed false private final string task name channel state write request executor impl string task name channel state write request dispatcher dispatcher this task name dispatcher new link blocking deque default handover capacity channel state write request executor impl string task name channel state write request dispatcher dispatcher block deque channel state write request deque this task name task name this dispatcher dispatcher this deque deque this thread new thread this run channel state writer task name this thread set daemon true visible for test void run try loop catch exception ex throw ex finally try close all this cleanup request dispatcher fail throw null new cancellation exception throw catch exception e noinspection non atomic operation on volatile field throw exception util first or suppress e throw log debug loop terminate task name private void loop throw exception while be close try dispatcher dispatch deque take catch interrupted exception e if be closed log debug task name interrupt while wait for a request continue wait e else thread current thread interrupt private void cleanup request throw exception throwable cause throw null new cancellation exception throw list channel state write request drain new array list deque drain to drain log info discard drain request task name drain size close all drain stream auto closeable map request request cancel cause collect collector to list override public void start throw illegal state exception this thread start override public void submit channel state write request request throw exception submit internal request deque add request override public void submit priority channel state write request request throw exception submit internal request deque add first request private void submit internal channel state write request request runnable with exception action throw exception try action run catch exception ex request cancel ex throw ex ensure run private void ensure run throw exception this check should be perform at least after enqueue a request check before be not enough because check enqueue be not atomic if be close thread be alive cleanup request throw exception util first or suppress new illegal state exception not run throw override public void close throw i o exception be closed true while thread be alive thread interrupt try thread join catch interrupted exception e if thread be alive thread current thread interrupt log debug task name interrupt while wait for the writer thread to die e if throw null throw new i o exception throw visible for test thread get thread return thread 
channel state writer impl internal thread safe public class channel state writer impl implement channel state writer private static final logger log logger factory get logger channel state writer impl class private static final int default max checkpoint include max concurrent checkpoint checkpoint to be abort schedule via mailbox private final string task name private final channel state write request executor executor private final concurrent map long channel state write result result private final int max checkpoint create a link channel state writer impl with link default max checkpoint as link max checkpoint public channel state writer impl string task name checkpoint storage worker view stream factory resolver this task name stream factory resolver default max checkpoint create a link channel state writer impl with link channel state serializer impl default link channel state serializer and a link channel state write request executor impl param task name param stream factory resolver a factory to obtain output stream factory for a give checkpoint param max checkpoint maximum number of checkpoint to be write currently or finish but not take yet channel state writer impl string task name checkpoint storage worker view stream factory resolver int max checkpoint this task name new concurrent hash map max checkpoint new channel state write request executor impl task name new channel state write request dispatcher impl stream factory resolver new channel state serializer impl max checkpoint channel state writer impl string task name concurrent map long channel state write result result channel state write request executor executor int max checkpoint this task name task name this result result this max checkpoint max checkpoint this executor executor override public void start long checkpoint id checkpoint option checkpoint option log debug start checkpoint task name checkpoint id checkpoint option channel state write result result new channel state write result channel state write result put result compute if absent checkpoint id id precondition check state result size max checkpoint string format s can t start d result size max checkpoint d d task name checkpoint id result size max checkpoint enqueue new checkpoint start request checkpoint id result checkpoint option get target location false return result precondition check argument put result task name result future already present for checkpoint checkpoint id override public void add input datum long checkpoint id input channel info info int start seq num closeable iterator buffer iterator log debug add input datum checkpoint channel start seq num task name checkpoint id info start seq num enqueue write checkpoint id info iterator false override public void add output datum long checkpoint id result subpartition info info int start seq num buffer datum log debug add output datum checkpoint channel start seq num num buffer task name checkpoint id info start seq num datum null datum length enqueue write checkpoint id info datum false override public void finish input long checkpoint id log debug finish input datum checkpoint task name checkpoint id enqueue complete input checkpoint id false override public void finish output long checkpoint id log debug finish output datum checkpoint task name checkpoint id enqueue complete output checkpoint id false override public void abort long checkpoint id throwable cause boolean cleanup log debug aborting checkpoint task name checkpoint id enqueue channel state write request abort checkpoint id cause true abort already start enqueue channel state write request abort checkpoint id cause false abort enqueue but not start if cleanup result remove checkpoint id override public channel state write result get and remove write result long checkpoint id log debug request write result checkpoint task name checkpoint id channel state write result result result remove checkpoint id precondition check argument result null task name channel state write result not find for checkpoint checkpoint id return result public void open executor start override public void close throw i o exception log debug close dropping checkpoint result key set result clear executor close private void enqueue channel state write request request boolean at the front state check and previous error check be perform inside the worker try if at the front executor submit priority request else executor submit request catch exception e runtime exception wrap new runtime exception unable to send request to worker e try request cancel e catch exception cancel exception wrap add suppress cancel exception throw wrap private static string build buffer type error message buffer buffer try abstract event event event serializer from buffer buffer channel state writer impl class get class loader return string format should be buffer but s find event catch exception ex return should be buffer 
blob library cache manager thread safe public class blob library cache manager implement library cache manager private static final logger log logger factory get logger blob library cache manager class the global lock to synchronize operation private final object lock object new object register entry per job guard by lock object private final map job i d library cache entry cache entry new hash map the blob service to download library guard by lock object private final permanent blob service blob service private final class loader factory class loader factory public blob library cache manager permanent blob service blob service class loader factory class loader factory this blob service check not null blob service this class loader factory check not null class loader factory override public class loader lease register class loader lease job i d job id synchronize lock object return cache entry compute if absent job id job i d new library cache entry job id obtain lease get the number of task hold link class loader reference for the give job param job id id of a job return number of reference holder int get number of reference holder job i d job id synchronize lock object library cache entry entry cache entry get job id return entry null entry get reference count return the number of register job that this library cache manager handle return number of job irrespective of the actual number of task per job int get number of manage job synchronize lock object return cache entry size override public void shutdown synchronize lock object for library cache entry entry cache entry value entry release class loader cache entry clear functional interface public interface class loader factory u r l class loader create class loader url library u r l private static final class default class loader factory implement class loader factory the resolve order to use when create a link class loader private final flink user code class loader resolve order class loader resolve order list of pattern for class that should always be resolve from the parent class loader if possible private final string always parent first pattern class loading exception handler private final consumer throwable class loading exception handler private default class loader factory flink user code class loader resolve order class loader resolve order string always parent first pattern consumer throwable class loading exception handler this class loader resolve order class loader resolve order this always parent first pattern always parent first pattern this class loading exception handler class loading exception handler override public u r l class loader create class loader url library u r l return flink user code class loader create class loader resolve order library u r l flink user code class loader class get class loader always parent first pattern class loading exception handler public static class loader factory default class loader factory flink user code class loader resolve order class loader resolve order string always parent first pattern nullable fatal error handler fatal error handler jvm metaspace oom error return new default class loader factory class loader resolve order always parent first pattern create class loading exception handler fatal error handler jvm metaspace oom error private static consumer throwable create class loading exception handler nullable fatal error handler fatal error handler jvm metaspace oom error return fatal error handler jvm metaspace oom error null class loading exception if exception util be metaspace out of memory error class loading exception fatal error handler jvm metaspace oom error on fatal error class loading exception flink user code class loader noop exception handler private final class library cache entry private final job i d job id guard by lock object private int reference count guard by lock object nullable private resolve class loader resolve class loader guard by lock object private boolean be release private library cache entry job i d job id this job id job id reference count this resolve class loader null this be release false private class loader get or resolve class loader collection permanent blob key library collection url class path throw i o exception synchronize lock object verify be not release if resolve class loader null resolve class loader new resolve class loader create user code class loader job id library class path library class path else resolve class loader verify class loader library class path return resolve class loader get class loader guard by lock object private u r l class loader create user code class loader job i d job id collection permanent blob key require jar file collection url require classpath throw i o exception try final url library u r l new url require jar file size require classpath size int count add u be l to locally cache jar file for permanent blob key key require jar file library u be l count blob service get file job id key to u be i to u be l count add classpath for url url require classpath library u be l count url count return class loader factory create class loader library u r l catch exception e rethrow or wrap exception util try rethrow i o exception e throw new i o exception library cache could not register the user code library e guard by lock object public int get reference count return reference count guard by lock object private default class loader lease obtain lease verify be not release reference count return default class loader lease create this private void release synchronize lock object if be release return if reference count reference count if reference count release class loader cache entry remove job id guard by lock object private void release class loader if resolve class loader null resolve class loader release class loader resolve class loader null be release true guard by lock object private void verify be not release precondition check state be release the library cache entry have already be release private static final class default class loader lease implement library cache manager class loader lease private final library cache entry library cache entry private boolean be closed private default class loader lease library cache entry library cache entry this library cache entry library cache entry this be closed false override public class loader get or resolve class loader collection permanent blob key require jar file collection url require classpath throw i o exception verify be not closed return library cache entry get or resolve class loader require jar file require classpath private void verify be not closed precondition check state be close the class loader handler have already be closed override public void release if be closed return be closed true library cache entry release private static default class loader lease create library cache entry library cache entry return new default class loader lease library cache entry private static final class resolve class loader private final u r l class loader class loader set of blob key use for a previous job task registration p the purpose of this be to make sure future registration do not differ in content as this be a contract of the link blob library cache manager private final set permanent blob key library set of class path u r l use for a previous job task registration p the purpose of this be to make sure future registration do not differ in content as this be a contract of the link blob library cache manager private final set string class path private resolve class loader u r l class loader class loader collection permanent blob key require library collection url require class path this class loader class loader note do not store the class path i e u be l into a set for performance reason see http findbug sourceforge net bug description html dmi collection of url alternatively compare they string representation this class path new hash set require class path size for url url require class path class path add url to string this library new hash set require library private u be l class loader get class loader return class loader private void verify class loader collection permanent blob key require library collection url require class path make sure the previous registration refer to the same library and class path note the original collection may contain duplicate and may not already be set collection with fast check whether a item be contain in it lazy construction of a new set for faster comparison if library size require library size new hash set require library contain all library throw new illegal state exception the library registration reference a different set of library b l o bs than previous registration for this job nold library nnew require library lazy construction of a new set with string representation of the u r l if class path size require class path size require class path stream map url to string collect collector to set contain all class path throw new illegal state exception the library registration reference a different set of library b l o bs than previous registration for this job nold class path nnew require class path release the class loader to ensure any file descriptor be closed and the cached library be delete immediately private void release class loader try class loader close catch i o exception e log warn fail to release user code class loader for array to string library to array 
heartbeat manager impl thread safe public class heartbeat manager impl i o implement heartbeat manager i o heartbeat timeout interval in milli seconds private final long heartbeat timeout interval ms resource id which be use to mark one own s heartbeat signal private final resource i would own resource i d heartbeat listener with which the heartbeat manager have be associate private final heartbeat listener i o heartbeat listener executor service use to run heartbeat timeout notification private final schedule executor main thread executor protect final logger log map contain the heartbeat monitor associate with the respective resource id private final concurrent hash map resource i d heartbeat monitor o heartbeat target private final heartbeat monitor factory o heartbeat monitor factory run state of the heartbeat manager protect volatile boolean stop public heartbeat manager impl long heartbeat timeout interval ms resource i d own resource i d heartbeat listener i o heartbeat listener schedule executor main thread executor logger log this heartbeat timeout interval ms own resource i d heartbeat listener main thread executor log new heartbeat monitor impl factory public heartbeat manager impl long heartbeat timeout interval ms resource i d own resource i d heartbeat listener i o heartbeat listener schedule executor main thread executor logger log heartbeat monitor factory o heartbeat monitor factory precondition check argument heartbeat timeout interval ms 0 l the heartbeat timeout have to be larger than this heartbeat timeout interval ms heartbeat timeout interval ms this own resource i d precondition check not null own resource i d this heartbeat listener precondition check not null heartbeat listener heartbeat listener this main thread executor precondition check not null main thread executor this log precondition check not null log this heartbeat monitor factory heartbeat monitor factory this heartbeat target new concurrent hash map stop false getter resource i would get own resource i would return own resource i d heartbeat listener i o get heartbeat listener return heartbeat listener map resource i d heartbeat monitor o get heartbeat target return heartbeat target heartbeat manager method override public void monitor target resource i d resource i d heartbeat target o heartbeat target if stop if heartbeat target contain key resource i would log debug the target with resource id be already be monitor resource i d else heartbeat monitor o heartbeat monitor heartbeat monitor factory create heartbeat monitor resource i d heartbeat target main thread executor heartbeat listener heartbeat timeout interval ms heartbeat target put resource i d heartbeat monitor check if we have stop in the meantime concurrent stop operation if stop heartbeat monitor cancel heartbeat target remove resource i would override public void unmonitor target resource i d resource i d if stop heartbeat monitor o heartbeat monitor heartbeat target remove resource i d if heartbeat monitor null heartbeat monitor cancel override public void stop stop true for heartbeat monitor o heartbeat monitor heartbeat target value heartbeat monitor cancel heartbeat target clear override public long get last heartbeat from resource i d resource id heartbeat monitor o heartbeat monitor heartbeat target get resource id if heartbeat monitor null return heartbeat monitor get last heartbeat else return 1 l schedule executor get main thread executor return main thread executor heartbeat target method override public void receive heartbeat resource i d heartbeat origin i heartbeat payload if stop log debug receive heartbeat from heartbeat origin report heartbeat heartbeat origin if heartbeat payload null heartbeat listener report payload heartbeat origin heartbeat payload override public void request heartbeat final resource i d request origin i heartbeat payload if stop log debug receive heartbeat request from request origin final heartbeat target o heartbeat target report heartbeat request origin if heartbeat target null if heartbeat payload null heartbeat listener report payload request origin heartbeat payload heartbeat target receive heartbeat get own resource i d heartbeat listener retrieve payload request origin heartbeat target o report heartbeat resource i d resource i d if heartbeat target contain key resource i d heartbeat monitor o heartbeat monitor heartbeat target get resource i d heartbeat monitor report heartbeat return heartbeat monitor get heartbeat target else return null 
buffer builder thread safe interface position marker int finish empty integer min value int get static boolean be finish int position return position static int get absolute int position if position finish empty return return math abs position 
system resource counter thread safe public class system resource counter extend thread private static final logger log logger factory get logger system resource counter class private final long probe interval m private final system info system info new system info private final hardware abstraction layer hardware abstraction layer system info get hardware private volatile boolean running true private long previous cpu tick private long byte receive per interface private long byte send per interface private volatile double cpu user private volatile double cpu nice private volatile double cpu sy private volatile double cpu idle private volatile double cpu i o wait private volatile double cpu irq private volatile double cpu soft irq private volatile double cpu usage private volatile double cpu load1 private volatile double cpu load5 private volatile double cpu load15 private atomic reference array double cpu usage per processor private final string network interface name private atomic long array receive rate per interface private atomic long array send rate per interface public system resource counter time probe interval probe interval ms probe interval to millisecond check state this probe interval ms set name system resource counter class get simple name probe thread cpu usage per processor new atomic reference array hardware abstraction layer get processor get logical processor count network i f network i f hardware abstraction layer get network i f byte receive per interface new long network i f length byte send per interface new long network i f length receive rate per interface new atomic long array network i f length send rate per interface new atomic long array network i f length network interface name new string network i f length for int i i network interface name length i network interface name i network i f i get name override public void run try while run calculate c p u usage hardware abstraction layer get processor calculate network usage hardware abstraction layer get network i f thread sleep probe interval ms catch interrupt exception e if running log warn have fail system resource counter class get simple name e public void shutdown throw interrupted exception run false interrupt join public double get cpu user return cpu user public double get cpu nice return cpu nice public double get cpu sy return cpu sy public double get cpu idle return cpu idle public double get i o wait return cpu i o wait public double get cpu irq return cpu irq public double get cpu soft irq return cpu soft irq public double get cpu usage return cpu usage public double get cpu load1 return cpu load1 public double get cpu load5 return cpu load5 public double get cpu load15 return cpu load15 public int get processor count return cpu usage per processor length public double get cpu usage per processor int processor return cpu usage per processor get processor public string get network interface name return network interface name public long get receive rate per interface int interface no return receive rate per interface get interface no public long get send rate per interface int interface no return send rate per interface get interface no private void calculate c p u usage central processor processor long tick processor get system cpu load tick if this previous cpu tick null this previous cpu tick tick long user tick tick tick type user get index previous cpu tick tick type user get index long nice tick tick tick type nice get index previous cpu tick tick type nice get index long sy tick tick tick type system get index previous cpu tick tick type system get index long idle tick tick tick type idle get index previous cpu tick tick type idle get index long iowait tick tick tick type iowait get index previous cpu tick tick type iowait get index long irq tick tick tick type irq get index previous cpu tick tick type irq get index long soft irq tick tick tick type softirq get index previous cpu tick tick type softirq get index long total cpu tick user tick nice tick sy tick idle tick iowait tick irq tick soft irq tick this previous cpu tick tick cpu user d user tick total cpu tick cpu nice d nice tick total cpu tick cpu sys d sy tick total cpu tick cpu idle d idle tick total cpu tick cpu i o wait d iowait tick total cpu tick cpu irq d irq tick total cpu tick cpu soft irq d soft irq tick total cpu tick cpu usage processor get system cpu load double load average processor get system load average cpu load1 load average double na n load average cpu load5 load average double na n load average cpu load15 load average double na n load average double load processor get processor cpu load between tick check state load length cpu usage per processor length for int i i load length i cpu usage per processor set i load i private void calculate network usage network i f network i f check state network i f length receive rate per interface length for int i i network i f length i network i f network i f network i f i network i f update network stats receive rate per interface set i network i f get byte recv byte receive per interface i probe interval m send rate per interface set i network i f get byte send byte send per interface i probe interval ms byte receive per interface i network i f get byte recv byte send per interface i network i f get byte send 
complete operation cache thread safe class complete operation cache k extend operation key r implement auto closeable async private static final long complete operation result cache duration seconds l private static final logger logger logger factory get logger complete operation cache class in progress asynchronous operation private final map k result access tracker r register operation trigger new concurrent hash map cache the result of complete operation private final cache k result access tracker r complete operation complete operation cache this ticker system ticker visible for test complete operation cache final ticker ticker complete operation cache builder new builder expire after write complete operation result cache duration seconds time unit seconds removal listener removal listener k result access tracker r removal notification if removal notification be evict precondition check state removal notification get key null precondition check state removal notification get value null when shut down the cache we wait until all result be access when a result get evict from the cache it will not be possible to access it any longer and we might be in the process of shut down so we mark the result as access to avoid wait indefinitely removal notification get value mark access logger info evict result with trigger id because its ttl of s have expire removal notification get key get trigger id complete operation result cache duration seconds ticker ticker build register a ongoing operation with the cache param operation result future a future contain the operation result public void register ongoing operation final k operation key final completable future r operation result future final result access tracker r in progress result access tracker in progress register operation trigger put operation key in progress operation result future when complete result error if error null complete operation put operation key in progress finish operation either right result else complete operation put operation key in progress finish operation either left error register operation trigger remove operation key return the operation result or a code throwable if the code completable future finish otherwise code null throw unknown operation key exception if the operation be not find and there be no ongoing operation under the provide key nullable public either throwable r get final k operation key throw unknown operation key exception result access tracker be result access tracker if result access tracker register operation trigger get operation key null result access tracker complete operation get if present operation key null throw new unknown operation key exception operation key return result access tracker access operation result or error override public completable future void close async return future util or timeout async wait for result to be access complete operation result cache duration seconds time unit seconds private completable future void async wait for result to be access return future util wait for all stream concat register operation trigger value stream complete operation as map value stream map result access tracker get access future collect collector to list visible for test void clean up complete operation clean up store the result of a asynchronous operation and track access to it private static class result access tracker r result of a asynchronous operation null if operation be in progress nullable private final either throwable r operation result or error future that complete if a non null link operation result or error be access private final completable future void access private static r result access tracker r in progress return new result access tracker private result access tracker this operation result or error null this access new completable future private result access tracker final either throwable r operation result or error final completable future void access this operation result or error check not null operation result or error this access check not null access create a new instance of the tracker with the result of the asynchronous operation set public result access tracker r finish operation final either throwable r operation result or error check state this operation result or error null return new result access tracker check not null operation result or error this access if present return the result of the asynchronous operation and mark the result as access if the result be not present this method return null nullable public either throwable r access operation result or error if operation result or error null mark access return operation result or error public completable future void get access future return access private void mark access access complete null 
in flight request tracker thread safe class in flight request tracker private final completable future void termination future new completable future private final phaser phaser new phaser override protect boolean on advance final int phase final int register party termination future complete null return true register a in flight request public void register request phaser register deregister a in flight request public void deregister request phaser arrive and deregister return a future that complete when the in flight request that be register prior to call this method be deregister public completable future void await async phaser arrive and deregister return termination future 
metric store thread safe public class metric store private static final logger log logger factory get logger metric store class private final component metric store job manager new component metric store private final map string task manager metric store task manager new concurrent hash map private final map string job metric store job new concurrent hash map remove inactive task manager param active task manager to retain synchronize void retain task manager list string active task manager task manager key set retain all active task manager remove inactive job param active job to retain synchronize void retain job list string active job job key set retain all active job add metric dump to the store param metric dump to add synchronize void add all list metric dump metric dump for metric dump metric metric dump add metric accessor for sub metric store return the link component metric store for the job manager return component metric store for the job manager public synchronize component metric store get job manager metric store return component metric store unmodifiable job manager return the link task manager metric store for the give taskmanager id param tm i d taskmanager id return task manager metric store for the give id or null if no store for the give argument exist public synchronize task manager metric store get task manager metric store string tm i d return tm i d null null task manager metric store unmodifiable task manager get tm i d return the link component metric store for the give job id param job i d job id return component metric store for the give id or null if no store for the give argument exist public synchronize component metric store get job metric store string job i d return job i d null null component metric store unmodifiable job get job i d return the link component metric store for the give job task id param job i d job id param task i d task id return component metric store for give i d or null if no store for the give argument exist public synchronize task metric store get task metric store string job i d string task i d job metric store job job i d null null job get job i d if job null task i d null return null return task metric store unmodifiable job get task metric store task i d return the link component metric store for the give job task id and subtask index param job i d job id param task i d task id param subtask index subtask index return subtask metric store for the give i d and index or null if no store for the give argument exist public synchronize component metric store get subtask metric store string job i d string task i d int subtask index job metric store job job i d null null job get job i d if job null return null task metric store task job get task metric store task i d if task null return null return component metric store unmodifiable task get subtask metric store subtask index public synchronize map string job metric store get job return unmodifiable map job public synchronize map string task manager metric store get task manager return unmodifiable map task manager deprecate use semantically equivalent link get job manager metric store deprecate public synchronize component metric store get job manager return component metric store unmodifiable job manager visible for test public void add metric dump metric try query scope info info metric scope info task manager metric store tm job metric store job task metric store task component metric store subtask string name info scope be empty metric name info scope metric name if name be empty malformed transmission return switch info get category case info category jm add metric job manager metric name metric break case info category tm string tm i d query scope info task manager query scope info info task manager i d tm task manager compute if absent tm i d k new task manager metric store if name contain garbage collector string gc name name substring status jvm garbage collector length name last index of tm add garbage collector name gc name add metric tm metric name metric break case info category job query scope info job query scope info job info query scope info job query scope info info job job compute if absent job info job i d k new job metric store add metric job metric name metric break case info category task query scope info task query scope info task info query scope info task query scope info info job job compute if absent task info job i d k new job metric store task job task compute if absent task info vertex i d k new task metric store subtask task subtask compute if absent task info subtask index k new component metric store the duplication be intend metric scop by subtask be useful for several job task handler while the web interface task metric query currently do not account for subtask so we don t divide by subtask and instead use the concatenation of subtask index and metric name as the name for those add metric subtask metric name metric add metric task metric task info subtask index name metric break case info category operator query scope info operator query scope info operator info query scope info operator query scope info info job job compute if absent operator info job i d k new job metric store task job task compute if absent operator info vertex i d k new task metric store subtask task subtask compute if absent operator info subtask index k new component metric store as the web interface do not account for operator because it can t we don t divide by operator and instead use the concatenation of subtask index operator name and metric name as the name add metric subtask metric operator info operator name name metric add metric task metric operator info subtask index operator info operator name name metric break default log debug invalid metric dump category info get category catch exception e log debug malformed metric dump e private void add metric map string string target string name metric dump metric switch metric get category case metric category counter metric dump counter dump counter metric dump counter dump metric target put name string value of counter count break case metric category gauge metric dump gauge dump gauge metric dump gauge dump metric target put name gauge value break case metric category histogram metric dump histogram dump histogram metric dump histogram dump metric target put name min string value of histogram min target put name max string value of histogram max target put name mean string value of histogram mean target put name median string value of histogram median target put name stddev string value of histogram stddev target put name p75 string value of histogram p75 target put name p90 string value of histogram p90 target put name p95 string value of histogram p95 target put name p98 string value of histogram p98 target put name p99 string value of histogram p99 target put name p999 string value of histogram p999 break case metric category meter metric dump meter dump meter metric dump meter dump metric target put name string value of meter rate break sub metric store class structure contain metric of a single component thread safe public static class component metric store public final map string string metric private component metric store this new concurrent hash map private component metric store map string string metric this metric check not null metric public string get metric string name return this metric get name public string get metric string name string default value string value this metric get name return value null value default value private static component metric store unmodifiable component metric store source if source null return null return new component metric store unmodifiable map source metric sub structure contain metric of a single task manager thread safe public static class task manager metric store extend component metric store public final set string garbage collector name private task manager metric store this new concurrent hash map concurrent hash map new key set private task manager metric store map string string metric set string garbage collector name super metric this garbage collector name check not null garbage collector name private void add garbage collector name string name garbage collector name add name private static task manager metric store unmodifiable task manager metric store source if source null return null return new task manager metric store unmodifiable map source metric unmodifiable set source garbage collector name sub structure contain metric of a single job thread safe private static class job metric store extend component metric store private final map string task metric store task new concurrent hash map public task metric store get task metric store string task i d return task i d null null task get task i d sub structure contain metric of a single task thread safe public static class task metric store extend component metric store private final map integer component metric store subtask private task metric store this new concurrent hash map new concurrent hash map private task metric store map string string metric map integer component metric store subtask super metric this subtask check not null subtask public component metric store get subtask metric store int subtask index return subtask get subtask index public collection component metric store get all subtask metric store return subtask value private static task metric store unmodifiable task metric store source if source null return null return new task metric store unmodifiable map source metric unmodifiable map source subtask 
metric store thread safe public static class component metric store public final map string string metric private component metric store this new concurrent hash map private component metric store map string string metric this metric check not null metric public string get metric string name return this metric get name public string get metric string name string default value string value this metric get name return value null value default value private static component metric store unmodifiable component metric store source if source null return null return new component metric store unmodifiable map source metric 
metric store thread safe public static class task manager metric store extend component metric store public final set string garbage collector name private task manager metric store this new concurrent hash map concurrent hash map new key set private task manager metric store map string string metric set string garbage collector name super metric this garbage collector name check not null garbage collector name private void add garbage collector name string name garbage collector name add name private static task manager metric store unmodifiable task manager metric store source if source null return null return new task manager metric store unmodifiable map source metric unmodifiable set source garbage collector name 
metric store thread safe private static class job metric store extend component metric store private final map string task metric store task new concurrent hash map public task metric store get task metric store string task i d return task i d null null task get task i d 
metric store thread safe public static class task metric store extend component metric store private final map integer component metric store subtask private task metric store this new concurrent hash map new concurrent hash map private task metric store map string string metric map integer component metric store subtask super metric this subtask check not null subtask public component metric store get subtask metric store int subtask index return subtask get subtask index public collection component metric store get all subtask metric store return subtask value private static task metric store unmodifiable task metric store source if source null return null return new task metric store unmodifiable map source metric unmodifiable map source subtask 
akka rpc service thread safe public class akka rpc service implement rpc service private static final logger log logger factory get logger akka rpc service class static final int version private final object lock new object private final actor system actor system private final akka rpc service configuration configuration guard by lock private final map actor ref rpc endpoint actor new hash map private final string address private final int port private final boolean capture ask callstack private final schedule executor internal schedule executor private final completable future void termination future private final supervisor supervisor private volatile boolean stop visible for test public akka rpc service final actor system actor system final akka rpc service configuration configuration this actor system check not null actor system actor system this configuration check not null configuration akka rpc service configuration address actor system address akka util get address actor system if actor system address host be define address actor system address host get else address if actor system address port be define port integer actor system address port get else port capture ask callstack configuration capture ask call stack internal schedule executor new actor system schedule executor adapter actor system termination future new completable future stop false supervisor start supervisor actor private supervisor start supervisor actor final executor service termination future executor executor new single thread executor new executor thread factory akka rpc service supervisor termination future executor final actor ref actor ref supervisor actor start supervisor actor actor system termination future executor return supervisor create actor ref termination future executor public actor system get actor system return actor system protect int get version return version override public string get address return address override public int get port return port this method do not mutate state and be thus thread safe override public c extend rpc gateway completable future c connect final string address final class c clazz return connect internal address clazz actor ref actor ref tuple2 string string address hostname extract address hostname actor ref return new akka invocation handler address hostname f0 address hostname f1 actor ref configuration get timeout configuration get maximum framesize null capture ask callstack this method do not mutate state and be thus thread safe override public f extend serializable c extend fence rpc gateway f completable future c connect string address f fencing token class c clazz return connect internal address clazz actor ref actor ref tuple2 string string address hostname extract address hostname actor ref return new fence akka invocation handler address hostname f0 address hostname f1 actor ref configuration get timeout configuration get maximum framesize null fencing token capture ask callstack override public c extend rpc endpoint rpc gateway rpc server start server c rpc endpoint check not null rpc endpoint rpc endpoint final supervisor actor actor registration actor registration register akka rpc actor rpc endpoint final actor ref actor ref actor registration get actor ref final completable future void actor termination future actor registration get termination future log info start rpc endpoint for at rpc endpoint get class get name actor ref path final string akka address akka util get akka u be l actor system actor ref final string hostname option string host actor ref path address host if host be empty hostname localhost else hostname host get set class implement rpc gateway new hash set rpc util extract implement rpc gateway rpc endpoint get class implement rpc gateway add rpc server class implement rpc gateway add akka base endpoint class final invocation handler akka invocation handler if rpc endpoint instanceof fence rpc endpoint a fence rpc endpoint need a fence akka invocation handler akka invocation handler new fence akka invocation handler akka address hostname actor ref configuration get timeout configuration get maximum framesize actor termination future fence rpc endpoint rpc endpoint get fencing token capture ask callstack implement rpc gateway add fence main thread executable class else akka invocation handler new akka invocation handler akka address hostname actor ref configuration get timeout configuration get maximum framesize actor termination future capture ask callstack rather than use the system class loader directly we derive the class loader from this class that work better in case where flink run embed and all flink code be load dynamically for example from a osgi bundle through a custom class loader class loader class loader get class get class loader suppress warning unchecked rpc server server rpc server proxy new proxy instance class loader implement rpc gateway to array new class implement rpc gateway size akka invocation handler return server private c extend rpc endpoint rpc gateway supervisor actor actor registration register akka rpc actor c rpc endpoint final class extend abstract actor akka rpc actor type if rpc endpoint instanceof fence rpc endpoint akka rpc actor type fence akka rpc actor class else akka rpc actor type akka rpc actor class synchronize lock check state stop rpc service be stop final supervisor actor start akka rpc actor response start akka rpc actor response supervisor actor start akka rpc actor supervisor get actor actor termination future prop create akka rpc actor type rpc endpoint actor termination future get version configuration get maximum framesize rpc endpoint get endpoint id final supervisor actor actor registration actor registration start akka rpc actor response or else throw cause new akka rpc runtime exception string format could not create the s for s akka rpc actor class get simple name rpc endpoint get endpoint id cause actor put actor registration get actor ref rpc endpoint return actor registration override public f extend serializable rpc server fence rpc server rpc server rpc server f fencing token if rpc server instanceof akka base endpoint invocation handler fence invocation handler new fence akka invocation handler rpc server get address rpc server get hostname akka base endpoint rpc server get actor ref configuration get timeout configuration get maximum framesize null fencing token capture ask callstack rather than use the system class loader directly we derive the class loader from this class that work better in case where flink run embed and all flink code be load dynamically for example from a osgi bundle through a custom class loader class loader class loader get class get class loader return rpc server proxy new proxy instance class loader new class rpc server class akka base endpoint class fence invocation handler else throw new runtime exception the give rpc server must implement the akka gateway in order to fence it override public void stop server rpc server self gateway if self gateway instanceof akka base endpoint final akka base endpoint akka client akka base endpoint self gateway final rpc endpoint rpc endpoint synchronize lock if stop return else rpc endpoint actor remove akka client get actor ref if rpc endpoint null terminate akka rpc actor akka client get actor ref rpc endpoint else log debug rpc endpoint already stop or from different rpc service self gateway get address override public completable future void stop service final completable future void akka rpc actor termination future synchronize lock if stop return termination future log info stop akka rpc service stop true akka rpc actor termination future terminate akka rpc actor final completable future void supervisor termination future future util compose afterwards akka rpc actor termination future supervisor close async final completable future void actor system termination future future util compose afterwards supervisor termination future future util to java actor system terminate actor system termination future when complete void ignore throwable throwable if throwable null termination future complete exceptionally throwable else termination future complete null log info stop akka rpc service return termination future guard by lock nonnull private completable future void terminate akka rpc actor final collection completable future void akka rpc actor termination future new array list actor size for map entry actor ref rpc endpoint actor ref rpc endpoint entry actor entry set akka rpc actor termination future add terminate akka rpc actor actor ref rpc endpoint entry get key actor ref rpc endpoint entry get value actor clear return future util wait for all akka rpc actor termination future private completable future void terminate akka rpc actor actor ref akka rpc actor ref rpc endpoint rpc endpoint akka rpc actor ref tell control message terminate actor ref no sender return rpc endpoint get termination future override public completable future void get termination future return termination future override public executor get executor return actor system dispatcher override public schedule executor get schedule executor return internal schedule executor override public schedule future schedule runnable runnable runnable long delay time unit unit check not null runnable runnable check not null unit unit check argument delay 0 l delay must be zero or larger return internal schedule executor schedule runnable delay unit override public void execute runnable runnable actor system dispatcher execute runnable override public t completable future t execute callable t callable future t scala future future t future callable actor system dispatcher return future util to java scala future private helper method private tuple2 string string extract address hostname actor ref actor ref final string actor address akka util get akka u be l actor system actor ref final string hostname option string host actor ref path address host if host be empty hostname localhost else hostname host get return tuple2 of actor address hostname private c extend rpc gateway completable future c connect internal final string address final class c clazz function actor ref invocation handler invocation handler factory check state stop rpc service be stop log debug try to connect to remote rpc endpoint with address return a gateway address clazz get name final completable future actor ref actor ref future resolve actor address address final completable future handshake success message handshake future actor ref future then compose actor ref actor ref future util to java pattern ask actor ref new remote handshake message clazz get version configuration get timeout to millisecond handshake success message map to class tag module handshake success message apply handshake success message class return actor ref future then combine async handshake future actor ref actor ref handshake success message ignore invocation handler invocation handler invocation handler factory apply actor ref rather than use the system class loader directly we derive the class loader from this class that work better in case where flink run embed and all flink code be load dynamically for example from a osgi bundle through a custom class loader class loader class loader get class get class loader suppress warning unchecked c proxy c proxy new proxy instance class loader new class clazz invocation handler return proxy actor system dispatcher private completable future actor ref resolve actor address string address final actor selection actor sel actor system actor selection address return actor sel resolve one time util to duration configuration get timeout to completable future exceptionally error throw new completion exception new rpc connection exception string format could not connect to rpc endpoint under address s address error private inner class private static final class supervisor implement auto closeable async private final actor ref actor private final executor service termination future executor private supervisor actor ref actor executor service termination future executor this actor actor this termination future executor termination future executor private static supervisor create actor ref actor ref executor service termination future executor return new supervisor actor ref termination future executor public actor ref get actor return actor override public completable future void close async return executor util non block shutdown 30 l time unit seconds termination future executor 
default job leader service thread safe private final class job manager leader listener implement leader retrieval listener private final object lock new object job id identify the job to look for a leader private final job i d job id rpc connection to the job leader guard by lock nullable private register rpc connection job master id job master gateway j m t m registration success rpc connection leader id of the current job leader guard by lock nullable private job master id current job master id state of the listener private volatile boolean stop private job manager leader listener job i d job id this job id precondition check not null job id stop false rpc connection null current job master id null private job master id get current job master id synchronize lock return current job master id public void stop synchronize lock if stop stop true close rpc connection public void reconnect synchronize lock if stop log debug can not reconnect because the job manager leader listener have already be stop else if rpc connection null precondition check state rpc connection try reconnect illegal concurrent modification of the job manager leader listener rpc connection else log debug can not reconnect to a unknown job master override public void notify leader address nullable final string leader address nullable final uuid leader id optional job master id job manager lose leadership optional empty synchronize lock if stop log debug s leader retrieval listener report a new leader for job however the service be no longer run default job leader service class get simple name job id else final job master id job master id job master id from uuid or null leader id log debug new leader information for job address leader id job id leader address job master id if leader address null leader address be empty the leader lose leadership but there be no other leader yet job manager lose leadership optional of nullable current job master id close rpc connection else check whether we be already connect to this leader if object equal job master id current job master id log debug ongoing attempt to connect to leader of job ignore duplicate leader information job id else close rpc connection open rpc connection to leader address job master id send callback outside of the lock scope job manager lose leadership if present old job master id job leader listener job manager lose leadership job id old job master id guard by lock private void open rpc connection to string leader address job master id job master id precondition check state current job master id null rpc connection null can not open a new rpc connection if the previous connection have not be closed current job master id job master id rpc connection new job manager register rpc connection log leader address job master id rpc service get executor log info try to register at job manager with leader id leader address job master id to u u i would rpc connection start guard by lock private void close rpc connection if rpc connection null rpc connection close rpc connection null current job master id null override public void handle error exception exception if stop log debug s leader retrieval listener report a exception for job however the service be no longer run default job leader service class get simple name job id exception else job leader listener handle error exception rpc connection for the job manager task manager connection private final class job manager register rpc connection extend register rpc connection job master id job master gateway j m t m registration success job manager register rpc connection logger log string target address job master id job master id executor executor super log target address job master id executor override protect retry registration job master id job master gateway j m t m registration success generate registration return new default job leader service job manager retry registration log rpc service job manager job master gateway class get target address get target leader id retry registration configuration owner address own location override protect void on registration success j m t m registration success success filter out old registration attempt if object equal get target leader id get current job master id log info successful registration at job manager for job get target address job id job leader listener job manager gain leadership job id get target gateway success else log debug encounter obsolete job manager registration success from with leader session id get target address get target leader id override protect void on registration failure throwable failure filter out old registration attempt if object equal get target leader id get current job master id log info fail to register at job manager for job get target address job id job leader listener handle error failure else log debug obsolete job manager registration failure from with leader session id get target address get target leader id failure 
partition table thread safe public class partition table k private final map k set result partition i d track partition per key new concurrent hash map return whether any partition be be track for the give key public boolean have track partition k key return track partition per key contain key key start the tracking of the give partition for the give key public void start track partition k key collection result partition i would new partition id precondition check not null key precondition check not null new partition id if new partition id be empty return track partition per key compute key ignore partition id if partition id null partition id new hash set partition id add all new partition id return partition id stop the tracking of all partition for the give key public collection result partition i would stop track partition k key precondition check not null key set result partition i d store partition track partition per key remove key return store partition null collection empty list store partition stop the tracking of the give set of partition for the give key public void stop track partition k key collection result partition i would partition id precondition check not null key precondition check not null partition id if the key be unknown we do not fail here in line with shuffle environment release finish partition track partition per key compute if present key ignore result partition i d s result partition i d s remove all partition id return result partition i d s be empty null result partition i d s 
abstract collect result partition writer thread safe public abstract class abstract collect result partition writer extend mock result partition writer private final buffer provider buffer provider private final array deque buffer consumer buffer consumer new array deque public abstract collect result partition writer buffer provider buffer provider this buffer provider check not null buffer provider override public buffer builder get buffer builder int target channel throw i o exception interrupt exception return buffer provider request buffer builder block target channel override public buffer builder try get buffer builder int target channel throw i o exception return buffer provider request buffer builder target channel override public synchronize boolean add buffer consumer buffer consumer buffer consumer int target channel boolean be priority event throw i o exception check state target channel get number of subpartition buffer consumer add buffer consumer process buffer consumer return true private void process buffer consumer throw i o exception while buffer consumer be empty buffer consumer buffer consumer buffer consumer peek buffer buffer buffer consumer build try deserialize buffer buffer if buffer consumer be finish break buffer consumer pop close finally buffer recycle buffer override public synchronize void flush all try process buffer consumer catch i o exception e throw new runtime exception e override public void flush int subpartition index flush all protect abstract void deserialize buffer buffer buffer throw i o exception 
test buffer factory thread safe public class test buffer factory public static final int buffer size private static final buffer recycler recycler free buffer recycler instance private final int buffer size private final buffer recycler buffer recycler private final int pool size private int number of create buffer public test buffer factory int pool size int buffer size buffer recycler buffer recycler check argument buffer size this pool size pool size this buffer size buffer size this buffer recycler check not null buffer recycler public synchronize buffer create if number of create buffer pool size return null number of create buffer return new network buffer memory segment factory allocate unpool segment buffer size buffer recycler public synchronize int get number of create buffer return number of create buffer static test helper create a network buffer with default size i e link buffer size and unspecified datum of the give size param datum size size of the datum in the buffer i e the new writer index return a new buffer instance public static buffer create buffer int datum size return create buffer buffer size datum size create a network buffer with unspecified datum of the give size param buffer size size of the buffer param datum size size of the datum in the buffer i e the new writer index return a new buffer instance public static buffer create buffer int buffer size int datum size return new network buffer memory segment factory allocate unpool segment buffer size recycler buffer datum type data buffer datum size 
checkpoint barrier unaligner thread safe static class thread safe unaligner implement buffer receive listener closeable tag the state of which input channel have not receive the barrier such that newly arrive buffer need to be write in the unaligned checkpoint private final map input channel info boolean store new buffer the number of input channel which have receive or process the barrier private int num barrier receive a future indicate that all barrier of the a give checkpoint have be read private completable future void all barrier receive future future util complete void future the checkpoint id to guarantee that we would trigger only one checkpoint when read the same barrier from different channel p note this checkpoint be valid in respect to b receive b barrier in contrast to link checkpoint barrier unaligner current consume checkpoint id private long current receive checkpoint id 1 l private int num open channel private final subtask checkpoint coordinator checkpoint coordinator private final checkpoint barrier unaligner handler thread safe unaligner subtask checkpoint coordinator checkpoint coordinator checkpoint barrier unaligner handler input gate input gate store new buffer array stream input gate flat map gate gate get channel info stream collect collector to map function identity info false num open channel store new buffer size this checkpoint coordinator checkpoint coordinator this handler handler override public synchronize void notify barrier receive checkpoint barrier barrier input channel info channel info throw i o exception long barrier id barrier get id if current receive checkpoint id barrier id handle new checkpoint barrier handler execute in task thread handler notify checkpoint barrier notify checkpoint if barrier id current receive checkpoint id store new buffer get channel info if log be debug enable log debug receive barrier from channel handler task name channel info barrier id store new buffer put channel info false if num barrier receive num open channel all barrier receive future complete null override public synchronize void notify buffer receive buffer buffer input channel info channel info if store new buffer get channel info checkpoint coordinator get channel state writer add input datum current receive checkpoint id channel info channel state writer sequence number unknown of element buffer buffer recycle buffer else buffer recycle buffer override public synchronize void close throw i o exception all barrier receive future cancel false private synchronize void handle new checkpoint checkpoint barrier barrier throw i o exception long barrier id barrier get id if all barrier receive future be do checkpoint exception exception new checkpoint exception barrier id barrier id checkpoint decline subsume if be checkpoint pend we do not complete the current checkpoint another start before log warn receive checkpoint barrier for checkpoint before complete current checkpoint skip current checkpoint handler task name barrier id current receive checkpoint id let the task know we be not complete this final long current checkpoint id current receive checkpoint id handler execute in task thread handler notify abort current checkpoint id exception notify abort all barrier receive future complete exceptionally exception current receive checkpoint id barrier id store new buffer entry set for each store new buffer store new buffer set value true num barrier receive all barrier receive future new completable future checkpoint coordinator init checkpoint barrier id barrier get checkpoint option synchronize completable future void get all barrier receive future long checkpoint id if checkpoint id current receive checkpoint id return future util complete void future if checkpoint id current receive checkpoint id throw new illegal state exception checkpoint checkpoint id have not be start at all return all barrier receive future synchronize void on channel close throw i o exception num open channel if reset pending checkpoint handler notify abort current receive checkpoint id new checkpoint exception checkpoint failure reason checkpoint decline input end of stream synchronize boolean set cancel checkpoint id long cancel id if current receive checkpoint id cancel id current receive checkpoint id cancel id num barrier receive return false reset pend checkpoint current receive checkpoint id cancel id return true synchronize void try abort pend checkpoint long checkpoint id checkpoint exception exception throw i o exception if checkpoint id current receive checkpoint id reset pend checkpoint handler notify abort current receive checkpoint id exception private boolean reset pend checkpoint if num barrier receive return false store new buffer entry set for each store new buffer store new buffer set value false num barrier receive return true visible for test synchronize int get num open channel return num open channel visible for test synchronize long get current checkpoint id return current receive checkpoint id visible for test boolean be checkpoint pend return num barrier receive 
task mailbox impl thread safe public class task mailbox impl implement task mailbox lock for all concurrent op private final reentrant lock lock new reentrant lock internal queue of mail guard by lock private final deque mail queue new array deque condition that be trigger when the mailbox be no longer empty guard by lock private final condition not empty lock new condition the state of the mailbox in the lifecycle of open quiesce and close guard by lock private state state open reference to the thread that execute the mailbox mail nonnull private final thread task mailbox thread the current batch of mail a new batch can be create with link create batch and consume with link try take from batch private final deque mail batch new array deque performance optimization where have new mail queue be empty will not reflect the state of link batch private volatile boolean have new mail false public task mailbox impl nonnull final thread task mailbox thread this task mailbox thread task mailbox thread visible for test public task mailbox impl this thread current thread override public boolean be mailbox thread return thread current thread task mailbox thread override public boolean have mail check be mailbox thread return batch be empty have new mail override public optional mail try take int priority check be mailbox thread check take state condition mail head take or null batch priority if head null return optional of head if have new mail return optional empty final reentrant lock lock this lock lock lock try final mail value take or null queue priority if value null return optional empty have new mail queue be empty return optional of nullable value finally lock unlock override public nonnull mail take int priority throw interrupted exception illegal state exception check be mailbox thread check take state condition mail head take or null batch priority if head null return head final reentrant lock lock this lock lock lock interruptibly try mail head mail while head mail take or null queue priority null not empty await have new mail queue be empty return head mail finally lock unlock override public boolean create batch check be mailbox thread if have new mail batch be usually deplete by previous mailbox processor run main loop however put first may add a message directly to the batch if call from mailbox thread return batch be empty final reentrant lock lock this lock lock lock try mail mail while mail queue poll first null batch add last mail have new mail false return batch be empty finally lock unlock override public optional mail try take from batch check be mailbox thread check take state condition return optional of nullable batch poll first override public void put nonnull mail mail final reentrant lock lock this lock lock lock try check put state condition queue add last mail have new mail true not empty signal finally lock unlock override public void put first nonnull mail mail if be mailbox thread check put state condition batch add first mail else final reentrant lock lock this lock lock lock try check put state condition queue add first mail have new mail true not empty signal finally lock unlock nullable private mail take or null deque mail queue int priority if queue be empty return null iterator mail iterator queue iterator while iterator have next mail mail iterator next if mail get priority priority iterator remove return mail return null override public list mail drain list mail drain mail new array list batch batch clear final reentrant lock lock this lock lock lock try drain mail add all queue queue clear have new mail false return drain mail finally lock unlock private void check be mailbox thread if be mailbox thread throw new illegal state exception illegal thread detect this method must be call from inside the mailbox thread private void check put state condition if state open throw new illegal state exception mailbox be in state state but be require to be in state open for put operation private void check take state condition if state close throw new illegal state exception mailbox be in state state but be require to be in state open or quiesce for take operation override public void quiesce check be mailbox thread final reentrant lock lock this lock lock lock try if state open state quiesce finally this lock unlock nonnull override public list mail close check be mailbox thread final reentrant lock lock this lock lock lock try if state close return collection empty list list mail drop mail drain state close to unblock all not empty signal all return drop mail finally lock unlock nonnull override public state get state if be mailbox thread return state final reentrant lock lock this lock lock lock try return state finally lock unlock override public void run exclusively runnable runnable lock lock try runnable run finally lock unlock 
